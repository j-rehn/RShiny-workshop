---
title: "Interactive Outputs (Tables/Plots)"
author: "Jacqueline Rehn"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
library(tidyverse)
library(here)
```

# Why Use Interactive Tables and Plots?

Interactive outputs in Shiny apps make data analysis and interpretation more effective by enabling users to explore, filter, and visualize information dynamically, leading to deeper insights and more engaging presentations.

**User-Driven Exploration**: Users can sort, search, and filter data directly in the app, allowing them to focus on the most relevant information without needing to re-run code or reload pages.

**Custom Actions**: Tables built with `DT` can respond to user actions, such as row selection or cell editing, supporting workflows like data annotation or downstream analysis.

**Professional Presentation**: Interactive tables look polished and provide features like pagination, column highlighting, and export options, making them suitable for sharing with non-technical audiences.

**Deeper Insight Through Interaction**: Interactive plots allow users to zoom, pan, hover for details, and select subsets of data, making it easier to uncover trends and relationships that might be missed in static charts.

# Building Our RNA-Seq App

In this tutorial we will build a Shiny App for exploring results from a differential gene expression analysis performed on RNA-seq data. The data we are exploring has been saved in the `data/` directory and was generated by following the steps described in [RNA-seq analysis is easy as 1-2-3 with limma, Glimma and edgeR](https://bioconductor.org/packages/release/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow.html). The analysed data consisted of three cell populations (basal, luminal progenitor (LP) and mature luminal (ML)) sorted from the mammary glands of female virgin mice, each profiled in triplicate.

Within our app we will include a volcano plot of genes DE between cell types. We will also include some box-plots for deeper comparison of gene expression across cell types. Finally, we wish to generate a heatmap of DEG's across all cell types.

As we build the app, you see how to create a multitab structure. We will also demonstrate how to convert static tables/plots into interactive one's and compare the difference.

## Step 1: Creating the Basic Framework

Let's set up the basic structure of our app. Open a new R script and paste in the following code:

```{r framework}

# load required libraries
library(shiny)
library(tidyverse)
library(here)
library(pheatmap)

# import data
dge_results <- readRDS(here("data/top.treat.results.rds"))
lcpm <- readRDS(here("data/lcpm.rds"))
top_genes <- read_csv(here("data/top.DE.mouse.genes.csv"))
# replace colnames with group_sample ID
colnames(lcpm) <- c("LP_1", "ML_1", "Basal_1", "Basal_2", "ML_2", "LP_2", "Basal_3", "ML_3", "LP_3")

# subset lcpm for DEG's
deg_matrix <- lcpm[rownames(lcpm) %in% top_genes$gene, ]

# pivot to long format
deg_long <- as.data.frame(deg_matrix) %>%
  mutate(Gene = rownames(.)) %>%
  pivot_longer(-Gene, names_to = "Sample", values_to = "Expression") %>% 
  mutate(Group = ifelse(grepl("LP_", Sample), "LP",
                        ifelse(grepl("ML", Sample), "ML", "Basal")))


# Define UI
ui <- fluidPage(
  
  titlePanel("Gene Expression Visualization"),
  
  tabsetPanel(
    
    tabPanel("Static Volcano Plot",
             # Our input controls & outputs for the volcano plot will go here
    ),
    tabPanel("Static Box-plots",
             # Our input controls & outputs for the boxplots will go here
    ),
    tabPanel("Static Heatmap",
             # our output for heatmap will go here
    )
  )
)

# Define server logic
server <- function(input, output) {
  # Our server logic will go here
}

# Run the application 
shinyApp(ui = ui, server = server)

```

In this framework:

- `titlePanel()` creates a header for our app. 
- `tabsetPanel()` organizes the app’s content into multiple tabs, allowing users to switch between different views or sections within the same app interface.
- `tabPanel()` defines the content of each individual tab within a tabsetPanel().

We have also imported the RNA-seq data and prepared this ready to plot/display. The available data includes:

- `dge_results` : consists of a list object containing 3 dataframes. Each data frame represents a different cell type comparison (e.g. basal vs LP; basal vs ML). Within each data frame we have list of genes (SYMBOL) each of which has: calculated log-fold-change (logFC), Average expression (AveExpr), adjusted P-value (adj.P.Val), whether the change in expression is significant (isSignficant), and direction of change in expression (DE; Down/Up).  
- `lcpm` : is a matrix of normalised counts for all 9 Samples included in the analysis. 
- `top_genes` is a list of 121 genes representing top DEG's in the analysis.
- `deg_matrix` : is the matrix of normalised counts, subset for significant DE genes.
- `deg_long` : is the deg_matrix in long format with the cell type for each sample indicated (Group).

## Step 2: Adding Input Controls & Output elements

Now, let's add the input controls & output elements to our app:

```{r input-output-controls}

ui <- fluidPage(
  titlePanel("Gene Expression Visualization"),
  tabsetPanel(
    tabPanel("Static Volcano Plot",
             # Select contrast for volcano plot
             selectInput("contrast", "Select a contrast:", choices = names(dge_results)),
             # Display the volcano plot
             plotOutput("volcanoPlot"),
             # Display table of DEG's
             tableOutput("top_dge")
    ),
    tabPanel("Static Box-plots",
             # Select gene to plot
             selectInput("gene", "Select a gene to plot:", choices = top_genes$gene),
             # Display the box-plot
             plotOutput("boxplot")
    ),
    tabPanel("Static Heatmap",
             # display heatmap
             plotOutput("heatmap", height = 500)
    )
  )
)

```

Let's break down the input controls:

1. `selectInput("contrast", "Select a contrast:", choices = names(dge_results))`: Creates a dropdown menu for the user to select a contrast (comparison) from your differential gene expression (DGE) results.
   - `"contrast"` is the unique input ID used to access the user’s selection in the server logic
   - `"Select a contrast to review:"` is the label displayed above the dropdown.
   - `choices = names(dge_results)` populates the dropdown with the names of available contrasts from your DGE results list object.
  
2. `selectInput("gene", "Select a gene to plot:", choices = top_genes$gene)` : Creates a dropdown menu for users to select a specific gene to visualize.
   - `"gene"` is the input ID used to access the user's selection in the server logic.
   - `"Select a gene to plot:"` is the label shown above the dropdown.
   - `choices = top_genes$gene` populates the dropdown with gene names from the top_genes data frame.

Let's break down the output elements:

1. `plotOutput("volcanoPlot")`: Defines a space in the UI where a volcano plot will be displayed.
   - `"volcanoPlot"` is the output ID that we'll use in the server logic
   
2. `tableOutput("top_dge")` : Defines a space in the UI for displaying a table of top differentially expressed genes (DEGs).
   - `"top_dge"` is the output ID that we'll use in the server logic
   
3. `plotOutput("boxplot")` : Defines a UI area to display a boxplot for the selected gene.
   - `"boxplot"` is the output ID that we'll use in the server logic

4. `plotOutput("heatmap", height = 500)` : Allocates space in the UI for displaying a heatmap of DEG's
   - `"heatmap"` is the output ID that we'll use in the server logic
   - `height = 500` sets the plot area’s vertical size to 500 pixels for better visibility

## Step 3: Adding Server Logic

Now, let's write the server logic that processes inputs and creates outputs. Add the following code to your R script:

```{r server-logic}
server <- function(input, output) {
  
  # extract chosen DGE contrast from dge_results list
  contrast <- reactive({
    req(input$contrast)
    dge_results[[input$contrast]]
  })
  
  # generate volcano plot
  output$volcanoPlot <- renderPlot({
    
    contrast() %>%
      ggplot(aes(x = logFC, 
                 y = -log10(P.Value),
                 colour = DE,
                 text = paste("Gene:", SYMBOL, "\n",
                              "EntrezID:", ENTREZID, "\n",
                              "Chr:", TXCHROM, "\n"))) +
      geom_point(size = 1, alpha = 0.5) + 
      scale_colour_manual(values = c("blue", "grey", "red"), 
                          breaks = c("Down", "Not significant", "Up")) + 
      theme_bw() + 
      theme(axis.title = element_text(size = 14, face = "bold"),
            legend.title = element_text(size = 14, face = "bold"),
            legend.text = element_text(size = 14))
    
  })
  
  # generate table of DEG
  output$top_dge <- renderTable({
    
    filter(contrast(), isSignificant == TRUE) %>% 
      arrange(adj.P.Val) %>% 
      dplyr::select(SYMBOL, TXCHROM, logFC, adj.P.Val, DE) %>% 
      head(n=20)
    
  })
  
  # generate box-plot
  output$boxplot <- renderPlot({
    
    filter(deg_long, Gene == input$gene) %>% 
      ggplot(aes(x = Group, y = Expression)) + 
      geom_boxplot() + 
      scale_y_continuous(limits = c(-5, 15)) + 
      geom_jitter(aes(colour = Group)) + 
      theme_bw() + 
      theme(axis.text = element_text(size = 14),
            axis.title = element_text(size = 14, face = "bold"),
            legend.position = "none") + 
      labs(x = "Cell Type", y=expression("Counts per million (log"[2]*")"))
    
  })
  
  # generate heatmap
  output$heatmap <- renderPlot({
    pheatmap(deg_matrix, cluster_rows = TRUE, cluster_cols = TRUE)
  })
  
}

```

Let's break down the server logic:

1. **Reactive Contrast Selection**: 
   ```r
   contrast <- reactive({
    req(input$contrast)
    dge_results[[input$contrast]]
   })
   ```
   - Creates a reactive expression that selects the appropriate DGE results data frame based on the user's choice in the contrast dropdown menu
   - `input$contrast` comes from the UI dropdown.
   - The function returns the corresponding data frame from the `dge_results` list.
   - The result is accessed as `contrast()` elsewhere in the server logic.  
   
2. **Volcano Plot Generation**
   ```r
   output$volcanoPlot <- renderPlot({
    
    contrast() %>%
      ggplot(aes(x = logFC, 
                 y = -log10(P.Value),
                 colour = DE,
                 text = paste("Gene:", SYMBOL, "\n",
                              "EntrezID:", ENTREZID, "\n",
                              "Chr:", TXCHROM, "\n"))) +
      geom_point(size = 1, alpha = 0.5) + 
      scale_colour_manual(values = c("blue", "grey", "red"), 
                          breaks = c("Down", "Not significant", "Up")) + 
      theme_bw() + 
      theme(axis.title = element_text(size = 14, face = "bold"),
            legend.title = element_text(size = 14, face = "bold"),
            legend.text = element_text(size = 14))
    
   })
   ```
   - Renders a volcano plot for the selected contrast.
   - Uses the data from the selected contrast (`contrast()`)
   - Each point represents a gene; color indicates DEG status (`DE`)
   - Tooltip text is prepared (for possible interactive use).
   - Aesthetic and theme customizations improve readability.  
   
3. **Table of Top DEGs**
   ```r
   output$top_dge <- renderTable({
    
    filter(contrast(), isSignificant == TRUE) %>% 
      arrange(adj.P.Val) %>% 
      dplyr::select(SYMBOL, TXCHROM, logFC, adj.P.Val, DE) %>% 
      head(n=20)
    
   })
   ```
   - Displays a table of the top 20 significant DEGs for the selected contrast.
   - Filters for significant genes (`isSignificant == TRUE`).
   - Sorts by adjusted p-value (`adj.P.Val`), showing the most significant genes first.
   - Selects relevant columns for display.
   - Shows only the top 20 genes.  

4. **Boxplot Generation**
   ```r
   output$boxplot <- renderPlot({
    
    filter(deg_long, Gene == input$gene) %>% 
      ggplot(aes(x = Group, y = Expression)) + 
      geom_boxplot() + 
      scale_y_continuous(limits = c(-5, 15)) + 
      geom_jitter(aes(colour = Group)) + 
      theme_bw() + 
      theme(axis.text = element_text(size = 14),
            axis.title = element_text(size = 14, face = "bold"),
            legend.position = "none") + 
      labs(x = "Cell Type", y=expression("Counts per million (log"[2]*")"))
    
   })
   ```
   - Creates a boxplot showing expression levels of a selected gene across different groups/cell types.
   - `filter(deg_long, Gene == input$gene)` selects expression data for the user-chosen gene from `input$gene`.
   - `geom_boxplot()` shows distribution statistics (median, quartiles).
   - `geom_jitter()` overlays individual data points with group-specific coloring.
   - `scale_y_continuous(limits = c(-5, 15))` sets expression range.
   - Custom themes and labels improve readability.
   - `expression()` creates a formatted log₂ y-axis label.  

5. **Heatmap Generation**
   ```r
   output$heatmap <- renderPlot({
    pheatmap(deg_matrix, cluster_rows = TRUE, cluster_cols = TRUE)
   })
   ```
   - Displays a clustered heatmap of gene expression data.
   - `pheatmap()` from the pheatmap package generates the heatmap.
   - `cluster_rows = TRUE` applies hierarchical clustering to genes (rows).
   - `cluster_cols = TRUE` applies hierarchical clustering to samples/groups (columns).
   - Dendrograms are automatically displayed for both dimensions.


## Step 5: Create the complete Static App 

Now, let's put everything together to create our complete Shiny app:

1. Add `shinyApp(ui = ui, server = server)` to the final line of the script/markdown
2. Save the file with a name like "static_dgeVis_app.R".
3. Click the "Run App" button in RStudio (or use `shiny::runApp()` in the console)

If you have any trouble with these steps we have created a complete version of the static app to test. In `example_apps` open the file `05_static_DGEvis_app.R` and click the "Run App" button in RStudio.

Spend a few minutes exploring the app. What works well? Where can improvements be made?

## Step 6: Create An Interactive Table

One issue with the DEG results table is that the table only displays the top 20 results. Given there are over 1000 DEG's identified in this analysis, presenting data in this way is limiting. By converting this element of the app to an interactive table we can incorporate features such as pagination, search and sort functionality which would make these results much easier to explore.

To do this we will use the R package `DT` which provides an R interface to the JavaScript library DataTables, allowing R data frames or matrices to be rendered as interactive HTML tables in web applications, including Shiny apps. 

DT integrates seamlessly with Shiny by replacing standard table outputs:

 - Use `DTOutput()` in the UI instead of `tableOutput()`.  
 - Use `renderDT()` in the server instead of `renderTable()`. 
 
Let's try this out. Begin by making a copy of our static `static_dgeVis_app.R` (e.g. `interactive_dgeVis_app.R`). In the copy we will make the following changes to the app.

**A. Add the `DT` package to the top of the script**  
```r
library(DT)
```
**B. Update the UI**  
Replace:
```r
tableOutput("top_dge")
```
with:
```r
DTOutput("top_dge")
```
**C. Update the Server Logic**  
Replace:
```r
output$top_dge <- renderTable({
    # ... filter/select code ...
   })
```
with:
```r
output$top_dge <- renderDT({
    
    df <- filter(contrast(), isSignificant == TRUE) %>% 
      arrange(adj.P.Val) %>% 
      dplyr::select(SYMBOL, TXCHROM, logFC, adj.P.Val, DE)
    
    # pass table to DT and supply parameters
    datatable(df,
              rownames = FALSE,
              filter = "top",
              options = list(
                pageLength = 10,
                lengthChange = FALSE
              ))
    
  })
```

Let's breakdown the changes:

1.  **Alternate Output Function**
    - To output a DT table use `DTOutput("top_dge")` in place of `tableOutput("top_dge")`
    
2. **Alternate Render Function**
   - Uses `renderDT()` in place of `renderTable()`.
   - The **entire** filtered, sorted, selected table is assigned to a variable (`df`)
   - Uses `datatable()` from the DT package to create an interactive table.
   - Specifies several table features:
      - No row names (`rownames = FALSE`).
      - Filter box at the top (`filter = "top"`), allowing users to search within the table.
      - Pagination: Only 10 rows displayed per page (`pageLength = 10`), with navigation for more.
      - No option for users to change page length (`lengthChange = FALSE`).

Save the changes you have made and try re-running the app. If you have any issues you can test the version `example_apps/05a_DGEvis_DT_app.R`. 

**How does DT improve the table feature?**

Here we have included just a few table features offered by `DT` which has made the table much more user friendly. Additional features include:

**Features Set Directly in `datatable()`**

- `colnames`: Set custom column names.  
- `class`: Apply CSS classes for styling (e.g., "display", "compact").  
- `caption`: Add a table caption.  
- `selection`: Enable row/column selection ("single", "multiple", "none").  
- `editable`: Make the table editable (TRUE or FALSE).  
- `width/height`: Set table size in pixels.  

**Features Set Within `options = list()`**

- `lengthMenu`: Options for user to change page length (e.g., lengthMenu = c(5, 10, 20)).  
- `searching`: Enable/disable the global search box.  
- `ordering`: Enable/disable column sorting.  
- `autoWidth`: Automatically adjust column widths.  
- `columnDefs`: Set column-specific options (e.g., width, alignment).  

## Step 7: Making Plots Interactive with Plotly

Our table is interactive. What about the volcano plot? One of the simplest ways to convert a static ggplot2 plot into an interactive plot is with the R package `plotly` and the function `ggplotly()`

Let's try this out by continuing to modify our R script `interactive_dgeVis_app.R`. To the script make the following changes:

**A. Add the `plotly` package to the top of the script**
```r
library(plotly)
```

**B. Update the UI**  
Replace:
```r
plotOutput("volcanoPlot")
```
with:
```r
plotlyOutput("volcanoPlot")
```

**C. Update the Server Logic**  
Replace:
```r
output$volcanoPlot <- renderPlot({
  # ... ggplot code ...
})
```
with:
```r
output$volcanoPlot <- renderPlotly({
  p <- contrast() %>%
    ggplot(aes(x = logFC, 
               y = -log10(P.Value),
               colour = DE,
               text = paste("Gene:", SYMBOL, "\n",
                            "EntrezID:", ENTREZID, "\n",
                            "Chr:", TXCHROM, "\n"))) +
    geom_point(size = 1, alpha = 0.5) + 
    scale_colour_manual(values = c("blue", "grey", "red"), 
                        breaks = c("Down", "Not significant", "Up")) + 
    theme_bw() + 
    theme(axis.title = element_text(size = 14, face = "bold"),
          legend.title = element_text(size = 14, face = "bold"),
          legend.text = element_text(size = 14))
  ggplotly(p, tooltip = "text")
})
```

Let's Breakdown the changes we've made:

1.  **Alternate Output Function**
    - Replaced `plotOutput("volcanoPlot")` with`plotlyOutput("volcanoPlot")` to produce a Plotly plot
    
2. **Alternate Render Function**
   - Uses `renderPlotly()` in place of `renderPlot()`.
   - The original ggplot has been assigned to an object `p <-`
   - The static plot is converted to an interactive plot with `ggplotly(p, tooltip = "text")`
   - The `text` aesthetic was present in the static ggplot code but did nothing. When converted to an interactive Plotly plot (using `ggplotly()`), Plotly uses the text values to display informative tooltips when users hover over each point.

Save your changes and re-run the app. If you have any issues you can alternatively test the version `example_apps/05b_DGEvis_DT_Plotly_app.R`.

What features does `Plotly` offer in addition to 'informative tooltips' present when you hover over each point?

#### **NOTE!** 
A new version of ggplot is imminent which uses S7 class objects in place of the current S3. This could impact packages like `Plotly` which use ggplot objects.

## Step 8: Adding an Interactive Heatmap

`Plotly` works well with ggplot objects. But what about our heatmap? This is a specialised type of plot which incorporates hierarchical clustering of rows and columns which is why we used the R package `Pheatmap` rather than ggplot. Fortunately, there are R packages available which can create interactive heatmaps. For this tutorial we will use the package `heatmaply` which builds on the `plotly` visualization framework, using `plotly's` JavaScript engine to render interactive heatmaps with features such as zooming, panning, and tooltips that display cell values on hover.

Let's try this out by continuing to modify our R script `interactive_dgeVis_app.R`. To the script make the following changes:

**A. Add the `heatmaply` package to the top of the script**
```r
library(heatmaply)
```

**B. Update the UI**  
Replace:
```r
plotOutput("heatmap", height = "500px")
```
with:
```r
plotlyOutput("heatmap")
```

**C. Update the Server Logic**  
Replace:
```r
output$heatmap <- renderPlot({
  pheatmap(deg_matrix, cluster_rows = TRUE, cluster_cols = TRUE)
})
```
with:
```r
output$heatmap <- renderPlotly({
    heatmaply(
      deg_matrix,
      fontsize_row = 8,
      fontsize_col = 12,
      height = 900
    )
  })
```

Let's Breakdown the changes we've made:

1.  **Alternate Output Function**
    - Replaced `plotOutput("heatmap", height = 500)` with`plotlyOutput("heatmap", height = "500px")` to produce a Plotly plot
    
2. **Alternate Render Function**
   - Uses `renderPlotly()` in place of `renderPlot()`.
   - Uses `heamaply()` in place of `pheatmap()`
   - `fontsize_row` decreases size of gene names. `fontsize_col` increases size of column/sample labels
   - `height` increases height of the plot.

Save your changes and re-run the app If you have any issues you can test the version `example_apps/07b_DGEvis_DT_Plotly_app.R`.

Switching from `pheatmap` to `heatmaply` and using `plotlyOutput`/`renderPlotly` makes your heatmap interactive, enhancing data exploration and user engagement in your Shiny app.

## Step 9: Putting It All Together

Now, let's put everything together to create our complete interactive Shiny app:

```{r complete-interactive-app, eval=FALSE}

# load required libraries
library(shiny)
library(tidyverse)
library(here)
library(DT)
library(plotly)
library(heatmaply)

# import data
dge_results <- readRDS(here("data/top.treat.results.rds"))
lcpm <- readRDS(here("data/lcpm.rds"))
top_genes <- read_csv(here("data/top.DE.mouse.genes.csv"))
# replace colnames with group_sample ID
colnames(lcpm) <- c("LP_1", "ML_1", "Basal_1", "Basal_2", "ML_2", "LP_2", "Basal_3", "ML_3", "LP_3")

# subset lcpm for DEG's
deg_matrix <- lcpm[rownames(lcpm) %in% top_genes$gene, ]

# pivot to long format
deg_long <- as.data.frame(deg_matrix) %>%
  mutate(Gene = rownames(.)) %>%
  pivot_longer(-Gene, names_to = "Sample", values_to = "Expression") %>% 
  mutate(Group = ifelse(grepl("LP_", Sample), "LP",
                        ifelse(grepl("ML", Sample), "ML", "Basal")))

# Define UI
ui <- fluidPage(
  titlePanel("Gene Expression Visualization"),
  tabsetPanel(
    tabPanel("Volcano Plot",
             # Select contrast for volcano plot
             selectInput("contrast", "Select a contrast:", choices = names(dge_results)),
             # Display the volcano plot
             plotlyOutput("volcanoPlot"),
             # Display table of DEG's
             DTOutput("top_dge")
    ),
    tabPanel("Box-plots",
             # Select gene to plot
             selectInput("gene", "Select a gene to plot:", choices = top_genes$gene),
             # Display the box-plot
             plotOutput("boxplot")
    ),
    tabPanel("Heatmap",
             # display heatmap
             plotlyOutput("heatmap", height = "500px")
    )
  )
)

# Define Server Logic
server <- function(input, output) {
  
  # extract chosen DGE contrast from dge_results list
  contrast <- reactive({
    req(input$contrast)
    dge_results[[input$contrast]]
  })
  
  # generate volcano plot
  output$volcanoPlot <- renderPlotly({
    
    p <- contrast() %>%
      ggplot(aes(x = logFC, 
                 y = -log10(P.Value),
                 colour = DE,
                 text = paste("Gene:", SYMBOL, "\n",
                              "EntrezID:", ENTREZID, "\n",
                              "Chr:", TXCHROM, "\n"))) +
      geom_point(size = 1, alpha = 0.5) + 
      scale_colour_manual(values = c("blue", "grey", "red"), 
                          breaks = c("Down", "Not significant", "Up")) + 
      theme_bw() + 
      theme(axis.title = element_text(size = 14, face = "bold"),
            legend.title = element_text(size = 14, face = "bold"),
            legend.text = element_text(size = 14))
    
    ggplotly(p, tooltip = "text")
    
  })
  
  # generate table of DEG
  output$top_dge <- renderDT({
    
    df <- filter(contrast(), isSignificant == TRUE) %>% 
      arrange(adj.P.Val) %>% 
      dplyr::select(SYMBOL, TXCHROM, logFC, adj.P.Val, DE)
    
    # pass table to DT and supply parameters
    datatable(df,
              rownames = FALSE,
              filter = "top",
              options = list(
                pageLength = 10,
                lengthChange = FALSE
              ))
    
  })
  
  # generate box-plot
  output$boxplot <- renderPlot({
    
    filter(deg_long, Gene == input$gene) %>% 
      ggplot(aes(x = Group, y = Expression)) + 
      geom_boxplot() + 
      scale_y_continuous(limits = c(-5, 15)) + 
      geom_jitter(aes(colour = Group)) + 
      theme_bw() + 
      theme(axis.text = element_text(size = 14),
            axis.title = element_text(size = 14, face = "bold"),
            legend.position = "none") + 
      labs(x = "Cell Type", y=expression("Counts per million (log"[2]*")"))
    
  })
  
  # generate interactive heatmap
  output$heatmap <- renderPlotly({
    heatmaply(
      deg_matrix,
      fontsize_row = 8,
      fontsize_col = 12,
      height = 900
    )
  })
  
}

# Run the application 
shinyApp(ui = ui, server = server)

```

# How to Run the App

To run the app:

1. Create a new R script or RMarkdown file
2. Copy the complete code from above
3. Save the file with a name like "interactive_dgeVis_app.R" or "app.R"
4. Click the "Run App" button in RStudio (or use `shiny::runApp()` in the console)

# Key Shiny Concepts to Understand

## Interactive Outputs

Including interactive tables and visualisations adds value to your apps, making complex data analyses more accessible, interpretable, and actionable for end users. Remember:

- Use `plotlyOutput()` in the UI and `renderPlotly()` in the server to create interactive plots, enabling features like zooming, hovering, and dynamic tooltips.  
- Use `DTOutput()` in the UI and `renderDT()` in the server to display interactive, sortable, and filterable data tables with the `DT` package.  
- Use `heatmaply()` directly in the server to generate interactive heatmaps, and pair it with `plotlyOutput()` and `renderPlotly()` for display, leveraging Plotly’s interactivity for complex matrix data.  
- Customize interactivity and appearance by passing additional arguments to `plotly::ggplotly()`, `DT::datatable()`, and `heatmaply()`, allowing users to explore and analyze data more effectively.  

# Challenge Exercises

Now that you understand the basics, try these exercises to extend the app:

1. Use `plotly` to create interactive box-plots and explore the results.
2. Edit the `DT` data table to:  
    a. Add a table caption.  
    b. Disable/remove the global search bar above the table.  
    c. Set custom column names.  
3. Use `?heatmaply()` to explore additional customization for the interactive heatmap. Try changing the plot colours, removing the dendogram etc.
4. Explore the R package [ggvis](https://ggvis.rstudio.com/ggvis-basics.html). How might these interactive plots be useful?

# Conclusion

In this tutorial, you've learned:  

1. How to structure an app to have multiple tabs.
2. How to convert static tables into interactive tables with `DT`.
3. How to convert static ggplots into interactive plots with `plotly` and `ggplotly`.
4. How to create interactive heatmaps with `heatmaply`.

By incorporating interactive tables and plots into your Shiny app, you significantly enhance the user experience and the value of your data analysis. With these features, your applications become not just static reports but responsive, user-driven tools for data analysis and visualization, empowering users to gain deeper insights and make more informed decisions. 

# Resources for Further Learning

- [RNA-seq analysis is easy as 1-2-3 with limma, Glimma and edgeR](https://bioconductor.org/packages/release/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow.html)
- [Using DT in Shiny](https://rstudio.github.io/DT/shiny.html)
- [Getting Started with Plotly in ggplot2](https://plotly.com/ggplot2/getting-started/)
- [Introduction to heatmaply](https://talgalili.github.io/heatmaply/articles/heatmaply.html)


